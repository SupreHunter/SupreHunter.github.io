<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MicroStation CE Addins开发（一）]]></title>
    <url>%2F2018%2F06%2F08%2FMicroStation%20CE%20Addins%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MicroStation是Bentley三维建模、文档制作及可视化软件的基础平台，且CE版本为适配windows64位操作系统平台的新版本，无论从软件应用到二次开发都新增了很多新特性。MSCE本身具有很强大的功能，但是往往在不同专业的生产环境中，该软件并不一定具备我们所需要的功能模块及使用习惯，那么Bentley提供了相应的SDK和开发接口，能够让我们在其强大的底层驱动下，发挥所长，开发出我们真切需求的功能，更加有效率地开展我们的工作。该文章是我在Bentley BDN社区及中国开发优先社区学习的一些心得总结，希望能帮助一些刚入门地朋友，了解MicroStation CE Addins相关开发。 Addins开发所需条件不管在什么平台上进行二次开发，都需要对该平台有一些了解，对相关软件的应用具备一定水平。Addins的开发基于Microsoft的.net平台，通过C#语言编码实现，所以您对于C#语言及C#的编译环境都需要有一定基础，网上有大量相关的学习资料。关于MSCE二次开发的内容，在BDN社区和开发优先社区都有大量的学习内容，建议多上网搜搜资料，有助于您的学习哦。 开发环境的配置需要您安装MicorStation CE版本的软件，更新版本比较多，请自行选择一个您试用的版本下载；建议安装VisualStudio 2015，我们需要在这个集成环境上面进行编译调试。 Hello World现在我们带您开始建立一个最简单的应用程序，在MSCE中装载运行。 新建项目启动VS2015，新建项目，窗体左侧选择C#，右侧选中类库，将.NET Frameworkshe设置为4.6.1，选择好路径和名称，点击OK创建项目。项目创建成功，左侧为C#代码，右侧是解决方案资源管理器窗体。右键解决方案资源管理器中的解决方案，选择属性，在生成（Bulid）选项卡下，修改output path，把它指向您的MSCE安装目录下的mdlapps文件夹，如果是默认安装，路径应该如下： C:\Program Files\Bentley\MicroStation CONNECT Edition\MicroStation\Mdlapps\ 这样，在生成解决方案的时候，就会自动在该文件夹下生成dll类库文件了。 添加引用给解决方案添加引用，加载我们在今后的开发过程中使用比较频繁的.NET类库（注：.NET类库是按需加载）。右键点击解决方案资源管理器中的引用，选择添加应用。首先在程序集——框架中找到System.Windows.Forms库，添加；再点击“浏览”按钮，分别浏览如下的路径，来加载dll库文件。 \MicroStation\Bentley.DgnDisplayNet.dll \MicroStation\Bentley.DgnPlatformNET.dll \MicroStation\Assemblies\ECFramework\Bentley.EC.Persistence3.dll \MicroStation\Assemblies\ECFramework\Bentley.ECObjects.Interop3.dll \MicroStation\Assemblies\ECFramework\Bentley.ECObjects3.dll \MicroStation\Assemblies\ECFramework\Bentley.ECSystem3.dll \MicroStation\Assemblies\ECFramework\Bentley.General.1.0.dll \MicroStation\Bentley.GeometryNET.dll \MicroStation\Bentley.GeometryNET.Common.dll \MicroStation\Bentley.GeometryNET.Structs.dll \MicroStation\Assemblies\Bentley.Interop.MicroStationDGN.dll \MicroStation\Assemblies\Bentley.MicroStation.dll \MicroStation\Assemblies\Bentley.MicroStation.Interfaces.1.0.dll \MicroStation\Assemblies\Bentley.MicroStation.Ribbon.dll \MicroStation\Assemblies\Bentley.MicroStation.WPF.dll \MicroStation\Assemblies\ECFramework\Bentley.Platform.dll \MicroStation\Assemblies\ECFramework\Bentley.UI.dll \MicroStation\Assemblies\ECFramework\Bentley.Windowing.dll \MicroStation\ustation.dll 编写代码将Class.cs的类名改一下，Myaddin.cs，并将代码写改成如下： using Bentley.MstnPlatformNET; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace helloworld { internal sealed class MyAddin : AddIn { public static MyAddin Addin = null; private MyAddin(System.IntPtr mdlDesc) : base(mdlDesc) { Addin = this; } protected override int Run(string[] commandLine) { MessageBox.Show(&quot;Hello World!&quot;); return 0; } } } 要使一个.NET程序集能够在MSCE中加载并作为Addin调用，需要满足如下三个条件：1.包含有一个派生于Bentley.MstnPlatformNET.Addin的类；2.该派生类必须提供一个单参数(IntPtr类型的MDL描述符)的构造函数，且该构造函数需要链接到基类构造函数上；3.该派生类必须覆盖Addin基类中的虚方法Run() 加载运行选择菜单栏“生成——生成解决方案”，创建后缀为.dll的应用程序，如果这个地方报错，提示没有权限访问目录的话。可以尝试把之前的生成路径改回来，改为bin\Debug，然后将生成的dll程序拖入Mdlapps文件夹中。启动MSCE，点击key-in按钮，打开窗口，在键入域中输入MDL LOAD helloworld并回车，此时应该弹出一个写着“Hello World！”的对话框。 至此，这个简单的Addin程序就编写完了，接下来我们就要继续深入研究MSCE上的二次开发了。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>二次开发</tag>
        <tag>microstation</tag>
        <tag>addins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MicroStation CE MDL开发（一）]]></title>
    <url>%2F2018%2F06%2F08%2FMicroStation%20CE%20MDL%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MicroStation是Bentley三维建模、文档制作及可视化软件的基础平台，且CE版本为适配windows64位操作系统平台的新版本，无论从软件应用到二次开发都新增了很多新特性。MSCE本身具有很强大的功能，但是往往在不同专业的生产环境中，该软件并不一定具备我们所需要的功能模块及使用习惯，那么Bentley提供了相应的SDK和开发接口，能够让我们在其强大的底层驱动下，发挥所长，开发出我们真切需求的功能，更加有效率地开展我们的工作。该文章是我在Bentley BDN社区及中国开发优先社区学习的一些心得总结，希望能帮助一些刚入门地朋友，了解MicroStation CE MDL相关开发 MDL开发所需条件不管在什么平台上进行二次开发，都需要对该平台有一些了解，对相关软件的应用具备一定水平。最早期的MDL开发手段是Bentley基于C语言自己发明的扩展语言，编译器和链接器均有Bentley提供，最后生成的程序扩展名为.ma，我们把这样的开发方法成为PureMDL。而如今的MDL已经演变为完全基于C++来开发，同时为了保留MDL的一些特性（如命令表、MDL特有资源等），仍然需要生成一个.ma文件，我们称这种新的MDL为NativeCode MDL。NativeCode MDL能使您采用面向对象的编程方式来写代码，还能使您直接调用任何VC++中可以调用的功能。MDL的开发基于C++语言编码实现，所以您对于C++语言及C++的编译环境都需要有一定基础，网上有大量相关的学习资料。关于MSCE二次开发的内容，在BDN社区和开发优先社区都有大量的学习内容，建议多上网搜搜资料，有助于您的学习哦 开发环境的配置需要您安装MicorStation CE版本的软件，更新版本比较多，请自行选择一个您试用的版本下载； 安装对应版本的SDK，该开发工具包中包含了相关开发的文档和编译环境，下面对SDK的组成逐一做个介绍： bin文件夹：该文件夹下含有生成最终应用程序所需的执行程序以及启动开发环境的批处理文件； doc文件夹：该文件夹下会有五个开发帮助文档，其中MicroStationApi.chm就是我们要用到的MDL C++帮助文档。其他四个是有关C#开发MSCE的帮助文档； Documentation文件夹：网页格式的SDK Readme； examples文件夹：大量的MDL C++或C#样例代码； include文件夹：C++头文件； library文件夹：C++库文件； MigrationTools文件夹：帮助您从V8i代码迁移到CE代码的一些工具； mki文件夹：制作文件的头文件，为mke文件服务的一些系统文件； eula.pdf文件：Bentley软件最终yoghurt授权协议； MicroStationDeveloperShell.bat文件：启动开发环境的批处理文件 建议安装VisualStudio 2015，在安装过程中一定要选择安装VC++，同时还要选择安装Windows 10 SDK组件，我们需要在这个集成环境上面进行编译调试 Hello World现在我们带您开始建立一个最简单的应用程序，在MSCE中装载运行 新建项目首先在硬盘的相应位置新建一个名为“helloworld”的文件夹，在文件夹内新建一个helloworld.cpp，启动一个文本编辑器，当然可以选择VS2015的集成环境，该文件中含有程序的入口点函数MdlMain，当应用程序被装载后会从该入口点开始执行。我们在该函数中调用了MDL C API函数mdlDialog_dmsgsPrint用以弹出一个消息框显示“Hello World！”字样，.cpp代码如下： #include &lt;Mstn\MdlApi\MdlApi.h&gt; extern &quot;C&quot; DLLEXPORT void MdlMain (int argc, WCharCP argv[]) { mdlDialog_dmsgsPrint (L&quot;Hello World&quot;); } 在cpp文件的同目录下，新建helloworld.r文件，该文件中定义了DllMdlApp资源，该资源的作用是将MA与指定的DLL文件关联起来，.r代码如下： #include &lt;Mstn\MdlApi\rscdefs.r.h&gt; #define DLLAPPID 1 DllMdlApp DLLAPPID = { L&quot;HELLOWORLD&quot;, L&quot;HelloWorld&quot; // taskid, dllName } 继续在同目录下，新建helloworld.mke的文件，该文件是生成项目的控制文件，在项目的生成过程中，bmake读取该文件的内容然后调用相应的编译器和链接器从源文件生成最终的MA和DLL，.mke代码如下： PolicyFile = MicroStationPolicy.mki DEFAULT_TARGET_PROCESSOR_ARCHITECTURE=x64 appName = helloworld appObjs = $(o)$(appName)$(oext) appRscs = $(o)$(appName).rsc baseDir = $(_MakeFilePath) mdlLibs = $(MSMDE)library/ %include mdl.mki #---------------------------------------------------------------------- # Create needed output directories if they don&apos;t exist #---------------------------------------------------------------------- always: ~mkdir $(o) ~mkdir $(rscObjects) ~mkdir $(reqdObjs) #---------------------------------------------------------------------- # Define macros for files included in our link and resource merge #---------------------------------------------------------------------- DLM_NO_SIGN = 1 DLM_OBJECT_DEST = $(o) DLM_NAME = $(appName) DLM_OBJECT_FILES = $(appObjs) DLM_NO_DLS = 1 DLM_NO_DEF = 1 DLM_NOENTRY = 1 DLM_NO_MANIFEST = 1 DLM_DEST = $(mdlapps) LINKER_LIBRARIES = $(mdlLibs)bentley.lib \ $(mdlLibs)mdlbltin.lib \ $(mdlLibs)BentleyGeom.lib \ $(mdlLibs)DgnPlatform.lib #-------------------------------------------- # Create command table and header file #-------------------------------------------- #$(baseDir)$(appName)cmd.h : $(baseDir)$(appName)cmd.r #$(o)$(appName)cmd.rsc : $(baseDir)$(appName)cmd.r #----------------------------------------------------------------------- # Generate resource files #----------------------------------------------------------------------- $(o)$(appName).rsc : $(baseDir)$(appName).r #---------------------------------------------------------------------- # Generate MA #---------------------------------------------------------------------- $(mdlapps)$(appName).ma : $(appRscs) $(msg) &gt; $(o)make.opt -o$@ $(appRscs) &lt; $(RLibCmd) @$(o)make.opt ~time #----------------------------------------------------------------------------------------- # Builds any necessary CODE modules and link them to DLL #----------------------------------------------------------------------------------------- $(o)$(appName)$(oext) : $(baseDir)$(appName).cpp %include dlmlink.mki 编译确认 helloworld.cpp helloworld.r helloworld.mke 三个文件都放在helloworld文件夹下，打开 MicroStation CONNECT Edition SDK ，键入命令进入该文件夹的路径下， CD （该helloworld文件夹的路径） 再次键入命令进行编译 bmake -a 编译过程需要等待一段时间，在黑窗口中会打印编译的过程，编译成功后会直接在MSTN安装目录下的Mdlapps文件夹中生成相应的dll和ma文件 加载运行启动MSCE，点击key-in按钮，打开窗口，在键入域中输入MDL LOAD helloworld并回车，此时应该在日志栏中打印一行“Hello World”的字样。 至此，这个简单的MDL程序就编写完了，接下来我们就要继续深入研究MSCE上的二次开发了。 mke文件详解MicroStation的老版本是支持跨平台开发的，所以其开发架构并没有沿用微软的体系而是采用了类似Unix/Linux的开发体系，即利用制作文件来控制整个项目的生成过程。 其中带有阴影的块为源代码（头文件、资源文件、类型文件、C++文件）；矩形块为一些执行程序（资源编译器、类型生成器、MDL库打包程序、C++源文件编译器、目标对象链接器等）；其它块为生成的中间文件或最终文件 MDL程序中的资源分命令表资源、对话框资源、消息资源、类型资源等，它们最终都生成到了ma（ma为MicroStation Application的缩写）这个文件中。这些都是Bentley公司特有的，必须按照规定的语法来写这些资源文件。而MDL中的C++源文件到动态链接库的生成过程和我们普通的C++文件编译和链接过程是相同的，都是调用的微软VS下的编译器cl.exe和链接器link.exe将cpp文件生成obj文件，再进而将obj文件（可能是多个）链接成一个dll文件。这两部分几乎独立的过程都是靠一个mke文件来控制的。 在制作文件中存在如下6中需要掌握的语法： 注释：以#号开头的行为注释行，bmake程序出现mke文件时会忽略这些行 宏定义：如appName = HelloWorld这样的形式。appName被称为宏名称，HelloWorld被称为宏的值 宏展开：以$(宏名称)形式表达。如果$(appName)$(oext)被展开后就是cpp 依赖：比如$(o)$(appName).rsc : $(baseDir)$(appName).r这样的形式，前者依赖于后者。当后者发生修改后，前者需要重新生成。否则会忽略这样的行。这样做的目的是为了加快整个项目的生成速度，仅对修改的内容生成目标文件 规则：如 $(mdlapps)$(appName).ma : $(appRscs) $(msg) &gt; $(o)make.opt -o$@ $(appRscs) &lt; $(RLibCmd) @$(o)make.opt ~time 这样的形式。由$(appRscs)生成$(appName).ma时，在所有mki（制作文件的头文件）中没有默认的规则，这里列出了显式的规则。最终调用的是命令$(RLibCmd)将多个rsc文件打包成了一个ma文件。$(RLibCmd)展开后其实就是SDK中bin文件夹下而rlib.exe 【注】：在依赖下面空了一行而没有直接跟规则的，表示到mki中查找默认规则 语句：如%include或%ifdef等这样以%开头的。要么执行包含动作，要么执行一些条件分支功能。 详细的mke文件语法可从SDK帮助文档MicroStationApi.chm的Creating a Makefile and Using the bmake Utility一节中查得。要想更深入地理解mke文件，还需要您读系统的mki文件，这些文件定义了许多系统内置的宏定义和规则 appName定义项目名称。当你要新建一个项目时，需要复制出一个文件夹，修改各文件名后，在mke文件中将appName这个宏的值修改为你新项目的名称 每增加一个.cpp文件需要修改appObjs的定义以及增加一行生成obj的行。注意，行尾的反斜杠符号是续行符，该续行符之后一定不能再有空格 如果调用了其他库中的函数，需要将含有该函数的库文件名添加到LINKER_LIBRARIES宏定义中 如果引用了其他系统的头文件，需要设置dirToSearch指向新的头文件所在的文件夹，然后包含mki 根据项目的不同，可能会含有命令表资源文件、对话框资源文件等等，需要将各资源文件都定义到appRscs宏中，类似cpp文件，每增加一个资源源文件.r就要增加一行从.r生成.rsc的定义。在mke中已经定义好了有关命令资源的处理行，只需要取消行首的注释符#号即可]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>二次开发</tag>
        <tag>microstation</tag>
        <tag>mdl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoCAD Civil 3D .NET二次开发 —— Hello World]]></title>
    <url>%2F2018%2F05%2F24%2FAutoCAD%20Civil%203D%20.NET%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94Hello%20World%2F</url>
    <content type="text"><![CDATA[AutoCAD Civil3D作为众多BIM软件中的一员，主要面向土木工程设计及图形文档编制，提供了三种API，分别是：.NET API，COM API和CustomXXX API（使用C++语言），本教程主要基于.NET API给大家介绍C3D二次开发的环境搭建和基础知识，引导大家完成一个Hello World小插件的编写。在平时的工作中，我们经常会遇到很多重复的操作，以及使用软件现有的基本功能无法高效率地解决一些问题，因此需要通过二次开发将这些简单重复的工作交由计算机完成 C3D二次开发所需条件首先，你必须熟悉C3D的软件应用，因为二次开发基于C3D的基本功能，只有熟悉了C3D本身的功能操作，才能知道通过二次开发能达到什么高度，也可以避免开发出已经现有的功能模块，浪费人力时间 其次，你需要掌握一门计算机语言，本例采用C#语言，对语言的掌握不做太深的要求，基础语法和应用掌握即可，可以在网上搜索相应的教程，多家理解联系，很快便可以掌握基础的语法 开发环境的配置编译环境本例使用的软件为：Civil3D 2017版本，其对应的.NET版本为4.6，所以推荐安装Visual Studio 2015。（推荐一个反编译软件.NETReflector，十分好用） .NET项目设置创建.NET解决方案有两种方式：手动创建和通过AutoCAD .NET向导创建，推荐使用手动创建，这样对各类配置和文件能有自己的理解 手动创建解决方案及项目在Visual Studio 2015中创建一个新的类库解决方案，位置放在自己选择的文件夹中，项目名称和解决方案的名称可以统一设置为helloworld 在解决方案管理器下，右键点击“引用”，选择“添加引用”，在弹出的窗口中点击下方的“浏览”，找到AutoCAD Civil 3D的安装位置，选择基础库文件：acdbmgd.dll,acmgd.dll,accoremgd.dll,AecBaseMgd.dll,AeccDbMgd.dll(有些在C3D的文件夹下，有些在AutoCAD 2017的文件夹下) 添加Autodesk.AutoCAD.Runtime命名空间，因为后面我们要实现一个接口，这个是该接口定义所在的命名空间 using Autodesk.AutoCAD.Runtime; 在类中实现IExtensionApplication接口，VS会自动提供实现接口代码完成的选项 注释掉这些方法的默认内容，否则会因为异常而无法正常加载 完成后代码应该如下： using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; using Autodesk.AutoCAD.Runtime; namespace helloworld { public class Class1 : IExtensionApplication { public void Initialize() { // throw new NotImplementedException(); } public void Terminate() { // throw new NotImplementedException(); } } } 利用向导创建解决方案和项目给大家分享一个AutoCAD.NET Wizard的百度云下载地址 链接:https://pan.baidu.com/s/1VPa_FLiWeszuuROGkY_9Aw 密码:6t0q 安装好以后，会在VS新建项目中C#下看到Autodesk的选项，引用库也可以在设置中勾选 定义命令项目设置完成后，需要创建一个公有方法，并为这个方法设置一个CommandMethod属性，以便可以通过C3D的命令行调用该方法。 添加Autodesk.AutoCAD.ApplicationServices命名空间 using Autodesk.AutoCAD.ApplicationServices; 在之前的代码中加入如下代码： [CommandMethod(&quot;hello&quot;)] public void SthToDo() { Application.DocumentManager.MdiActiveDocument.Editor.WriteMessage(&quot;Hello World!&quot;); } ###编译 直接点击菜单上的“生成” ———— “生成解决方案”，会在解决方案目录中的的“bin”——“Debug”目录下生成helloworld.dll的文件 ###加载及运行 ####手动加载程序及运行命令 在C3D中下方有一个命令行输入框，键入netload，在对话框中浏览到helloworld.dll的位置，加载 然后在命令行中继续键入相应的命令，调用我们插件的方法，本例的命令为：hello ####通过工具空间加载并运行 在C3D的工具空间中，点击“编辑工具箱按钮” —— 在工具箱管理器中，新建根类别，修改名称 —— 新建类别，修改名称 —— 新建工具，并设置属性 双击新建的工具，即可执行程序 总结以上就是在AutoCAD Civil 3D的命令行中输出“Hello World”，这样一个小样例的编写及加载过程，希望能带大家进入C3D的.NET二次开发的世界。在大家学习二次开发的过程中，帮助文档是十分重要的一环，分为两类：开发者指南和API参考指南。 开发者指南：通过样例代码及相应解释说明展示了如何利用.NET API编写代码，API参考指南包含了可用对象的完整列表 2014版开发者指南 2017版指南和API： 链接：https://pan.baidu.com/s/1bgYzhHu98OJJOZEGQ1molA 密码：a8us]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>二次开发</tag>
        <tag>Civil3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活不易，不知何时]]></title>
    <url>%2F2018%2F05%2F23%2F%E7%94%9F%E6%B4%BB%E4%B8%8D%E6%98%93%EF%BC%8C%E6%A2%A6%E5%BD%93%E5%89%8D%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;漫步西子湖畔，清风微抚，鸟语潺潺，历史文化之谦谦底蕴盘桓以感叹。如此安逸闲适的美景，却难掩当下的悲哀，尤其使人。无奈于四眼古井作诗一首，致已将失去的思想和自由，愿自由幸福之风吹满中华大地，不曾散去…&emsp;&emsp;生花绮，云端栖，&emsp;&emsp;活色生香万物灵。&emsp;&emsp;不如意，生此地，&emsp;&emsp;易水远去心清明。&emsp;&emsp;梦灿烂，西子畔，&emsp;&emsp;当逐星辰随遇安。&emsp;&emsp;前水潺，后倚栏，&emsp;&emsp;行路坎坷自由淡。]]></content>
      <categories>
        <category>随笔散文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱你所爱，行你所行，听从你心，无问西东]]></title>
    <url>%2F2018%2F01%2F15%2F%E7%88%B1%E4%BD%A0%E6%89%80%E7%88%B1%EF%BC%8C%E8%A1%8C%E4%BD%A0%E6%89%80%E8%A1%8C%EF%BC%8C%E5%90%AC%E4%BB%8E%E4%BD%A0%E5%BF%83%EF%BC%8C%E6%97%A0%E9%97%AE%E8%A5%BF%E4%B8%9C%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;看了《无问西东》，内心涟漪，很多感触让我觉得一时难以表达，唯借鲁迅先生名言以抒：我们从古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人，…虽是等于为帝王将相作家谱的所谓“正史”，也往往掩不住他们的光耀，这就是中国的脊梁。&emsp;&emsp;“中华文明是什么？你又是什么？你要为中华文明做什么？”泰戈尔在清华的演讲发人深思，让很多彷徨于当下之才者，不再迷惑，无私无畏。 &emsp;&emsp;可什么才是民族性呢？ &emsp;&emsp;片尾张震的独白：“看到和听到的，经常令你们沮丧，世俗是这样强大，强大到生不出改变它们的念头。可是如果有机会提前了解了你们的人生，知道青春也不过只有这些日子，不知你们是否还会在意的事情，比如占有多少，才更荣耀，拥有什么，才能被爱。” &emsp;&emsp;“等你们长大，你们因绿芽冒出土地而喜悦，会对出生的朝阳欢呼雀跃，也会给别人善意和温暖，但是却会在赞美别的生命的同时，常常，甚至永远忘了自己的珍贵。愿你在被打击的时，记起你的珍贵，抵抗恶意；愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。” &emsp;&emsp;如此震撼人心，正如那句“逝者已矣，生者如斯”，让人终于找到内心的真诚与答案，愿我们，对自己之生命有悟，不再随波逐流，不害怕，不辜负，活出自己的珍贵。人性中都有光辉与善良的一面，让我们在如此社会中不要忘记，无需修饰，永远怀念那份光辉的荣耀，因为那是民族百年求索的记忆，永不褪色的传奇。 &emsp;&emsp;情不知所起，“立德立言，无问西东”，坚守原则，勇往直前，无妄青春。]]></content>
      <categories>
        <category>随笔散文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreeJS（一）：WebGL规范，及一般框架]]></title>
    <url>%2F2018%2F01%2F14%2FThreeJS%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AWebGL%E8%A7%84%E8%8C%83%EF%BC%8C%E5%8F%8A%E4%B8%80%E8%88%AC%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍一个非常全面的学习网站：WebGL中文网，这篇文章也是在这个网站上学习的一些笔记心得吧，对WebGL感兴趣的同学可以上去好好学习一下。什么是WebGL呢，WebGL是在浏览器中实现三维效果的一套规范。打开浏览器，输入如下网址，进入一个浏览器的三维世界。 http://aleksandarrodic.com/p/jellyfish/ ThreeJS使用WebGL原生的API来写3D程序是一件非常痛苦的事情，幸好，有很多同行花业余时间写了一些WebGL开源框架，其中three.js就是非常优秀的一个，threejs是一个让用户通过javascript入手进入搭建webgl项目的类库。 下载three.js源自github的一个开源项目，先去下载代码，地址为： https://github.com/mrdoob/three.js 速度可能有点慢，我再附一个百度云的下载地址： 链接:https://pan.baidu.com/s/1bCears 密码:3jny 源代码目录结构代码包里面有很多东西，目前我们能用上的不多，有一些是必须要引入的文件，现在做一下简单介绍。 Build目录：包含两个文件，three.js和three.min.js。这是three.js最终被引用的文件。一个已经压缩，一个没有压缩的js文件。 Docs目录：这里是three.js的帮助文档，里面是各个函数的api，可惜并没有详细的解释。试图用这些文档来学会three.js是不可能的。 Examples目录：一些很有趣的例子demo，可惜没有文档介绍。对图像学理解不深入的同学，学习成本非常高。 Src目录：源代码目录，里面是所有源代码。 第一个框架HTML&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;!--引入依赖文件--&gt; &lt;script src=&quot;../src/three.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSScanvas { width: 100%; height: 100%; } JS// 定义一个场景 let scene = new THREE.Scene(); // 定义一个相机(透视相机) let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000); // 定义一个渲染器（使用WebGl来渲染图形） let renderer = new THREE.WebGLRenderer(); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement); // 定义一个几何体，添加到场景中 let geometry = new THREE.CubeGeometry(1,1,1); let material = new THREE.MeshBasicMaterial({color: 0x00ff00}); let cube = new THREE.Mesh(geometry, material); scene.add(cube); camera.position.z = 5; function render() { requestAnimationFrame(render); cube.rotation.x += 0.1; cube.rotation.y += 0.1; renderer.render(scene,camera); } render(); 可以运行一下代码，看一下效果。 三大组件 场景 场景是所有物体的容器，如果要显示一个苹果，就需要将苹果对象加入场景中。 相机 另一个组件是相机，相机决定了场景中哪个角度的景色会显示出来。相机就像人的眼睛一样，人站在不同位置，抬头或者低头都能够看到不同的景色。 场景只有一种，但是相机却又很多种。和现实中一样，不同的相机确定了呈相的各个方面。比如有的相机适合人像，有的相机适合风景，专业的摄影师根据实际用途不一样，选择不同的相机。对程序员来说，只要设置不同的相机参数，就能够让相机产生不一样的效果。 透视相机 THREE.PerspectiveCamera(fov, aspect, near, far) 参数： fov-Camera frustum vertical field of view(摄像机垂直视野); aspect-Camera frustum aspect ratio(照相机体宽比); near-Camera frustum near plane(摄像机近场); far-Camera frustum far plane(摄像机远场) 正交投影照相机 THREE.OrthographicCamera(left, right, top, bottom, near, far) 参数： left-Camera frustum left plane right-Camera frustum right plane top-Camera frustum top plane bottom-Camera frustum bottom plane near-Camera frustum near plane far-Camera frustum far plane 在透视投影下，同样大小的物体，在屏幕下远处的物体会比近处的物体小，而正交投影下两者是一样大小的。透视相机的视域是一个台体，正交相机的视域是立方体。 相机属性 camera.position.x = 500;//相机的位置 camera.position.y = 500; camera.position.z = 1000 camera.up.x = 0;//相机以哪个方向为上方 camera.up.y = 0; camera.up.z = 1; camera.lookAt({//相机看向哪个坐标 x : 0, y : 0, z : 0 }); 渲染器 最后一步就是设置渲染器，渲染器决定了渲染的结果应该画在页面的什么元素上面，并且以怎样的方式来绘制。 setSize方法设置的是canvas标签的大小，renderer.setSize(100,100)就等于 &lt;canvas style=&quot;width:100px;height:100px;&quot;&gt;&lt;/canvas&gt; 注意，渲染器的domElement元素，表示渲染器中的画布，所有的渲染都是画在domElement上的，所以这里的appendChild表示将这个domElement挂接在body下面，这样渲染的结果就能够在页面中显示了。 在threejs中，渲染器可以视为是canvas标签，相机可以视为画布。注意画布和canvas标签不是同一个东西，canvas标签是画布的容器。画布就好比一张图片，canvas标签就像img标签。 渲染有两种方式：实时渲染和离线渲染。其中一个重要的函数是requestAnimationFrame，这个函数就是让浏览器去执行一次参数中的函数，这样通过上面render中调用requestAnimationFrame()函数，requestAnimationFrame()函数又让rander()再执行一次，就形成了我们通常所说的游戏循环了。 第二个框架第二个框架将功能分为不同的函数，比较规范。 HTML&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=&quot;../src/three.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;canvas-frame&quot;&gt;&lt;/div&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; CSS#canvas-frame { border: none; cursor: pointer; width: 500px; height: 500px; background-color: #EEEEEE; } JSwindow.onload = function () { // 渲染器部分 let renderer; function initThree() { // 获取画布的宽高 width = document.getElementById(&apos;canvas-frame&apos;).clientWidth; height = document.getElementById(&apos;canvas-frame&apos;).clientHeight; // 声明渲染器对象：WebGLRenderer renderer = new THREE.WebGLRenderer({ antialias: true, }); // 指定渲染器的高宽（和画布框大小一致 renderer.setSize(width,height); // 添加canvas元素到页面中。 document.getElementById(&apos;canvas-frame&apos;).appendChild(renderer.domElement); // 设置canvas背景色(clearColor)和背景色透明度（clearAlpha） renderer.setClearColor(0xFFFFFF,1.0); } // 相机部分 let camera; function initCamera() { camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000); camera.position.x = 0; camera.position.y = 1000; camera.position.z = 0; camera.up.x = 0; camera.up.y = 0; camera.up.z = 1; camera.lookAt(0,0,0); } // 场景部分 let scene; function initScene() { scene = new THREE.Scene(); } // 光线部分 let light; function initLight() { light = new THREE.DirectionalLight(0xFF0000, 1.0, 0); light.position.set(100, 100, 200); scene.add(light); } // 物体部分 function initObject() { // 几何体 let geometry = new THREE.Geometry(); // 材质 let material = new THREE.LineBasicMaterial({ // 定义线条材质是否使用顶点颜色 vertexColors: THREE.VertexColors }); let color1 = new THREE.Color( 0x444444 ); let color2 = new THREE.Color( 0xFF0000 ); // 线的材质可以由2点的颜色决定 // 创建几何体的两个矢量点（x，y，z） let p1 = new THREE.Vector3( -100, 0, 100 ); let p2 = new THREE.Vector3( 100, 0, -100 ); // geometry.vertices是几何体用来存放点的集合 geometry.vertices.push(p1); geometry.vertices.push(p2); // geometry.colors是几何体用来存放颜色的集合 geometry.colors.push( color1, color2 ); // 定义一条线 let line = new THREE.LineSegments(geometry,material); // 把线添加到场景中 scene.add(line); } // 渲染函数 function render() { renderer.clear(); renderer.render(scene,camera); } function threeStart() { initThree(); initCamera(); initScene(); initLight(); initObject(); render(); } threeStart(); }; 可以运行一下代码，看一下效果。 渲染器//声明渲染器对象：WebGLRenderer renderer=new THREE.WebGLRenderer({ antialias:true, //是否开启反锯齿 precision:&quot;highp&quot;, //着色精度选择 alpha:true, //是否可以设置背景色透明 premultipliedAlpha:false, stencil:false, preserveDrawingBuffer:true, //是否保存绘图缓冲 maxLights:1 //maxLights:最大灯光数 }); 光源 环境光：AmbientLight 影响整个场景的光源，光源没有特定的来源，不能产生阴影。不能作为场景中唯一光源，言外之意，他是配合其他光源存在的。作用：弱化阴影或添加一些颜色（使用该光源，用色应尽量保守），该光源不需要设置光源的位置，直接添加到Scene中即可。 var ambientColor = &apos;0x0c0c0c&apos;; var ambientLight = new THREE.AmbientLight(ambientColor); scene.add(ambientLight); 点光源：PointLight 照射所有方向，点光源不会产生投影，因为他的光线照射所有的方向，计算投影的话对GPU来说是沉重的负担。属性：color；intensity 光源强度，默认为1； distance 光源照射的距离。默认为0，表示光线的亮度不会随着距离的增加而减少；position visible为true，该光源打开，为false，该光源关闭。 聚光灯：SpotLight 常用的光源，具有锥形效果，可以产生阴影， 属性：castShadow shaowCameraNear 从距离光源哪一点开始产生阴影； shadowCameraFar 从距离光源哪一点为止结束生成阴影； shadowCameraFov 用于生成阴影的视场有多大； target 决定光照的方向，一般是一个物体，即光源照向这个物体； shadowBias 偏移阴影的位置； angle 光源射出的光柱有多宽。默认 Math.PI/3； exponent 光强衰减指数，决定光强递减的有多快； onlyShadow 如果为true，则只产生阴影，不产生光照； shadowCameraVisible 如果为true，就可以看到光源的位置及如何生成阴影； shadowDarkness 阴影的阴暗程度，默认为0.5，场景渲染完毕之后不能修改； shadowMapWidth 决定多少像素渲染阴影，如果阴影边缘有锯齿可以增加这个值； shadowMapHeight 决定多少像素渲染阴影，如果阴影边缘有锯齿可以增加这个值； target属性我们可以设置场景中的任何一个物体，当前我们也可以设置空间的任何一点： var target = new THREE.Object3D(); target.position = new THREE.Vector3(5,0,0); spotLight.target = target; 方向光：DirectionalLight：无限光，例如太阳光，平行光，可以产生阴影，属性：direction（方向）；color（颜色）；intensity（强度）。 半球光：HemisphereLight：模拟更加自然的室外光线，反光面，光线微弱的天空 面光源：AreaLight：创建一个矩形的光源，AreaLight是一种复杂的光源，需要使用WebGLDeferredRenderer(WebGL延迟渲染器)。 镜头眩光：LensFlare var lensFlare = new THREE.LensFlare(texture,size,distance,blending,color); texture:纹理，决定眩光的样子； size：决定眩光多大。如果为-1，则使用纹理的大小； distance：光源(0)到相机的距离(1)； blending:融合，当我们为眩光提供多种材质时，该属性决定这些材质怎么融合，默认的融合模式是THREE.AdditiveBlending，它可以提供一种半透明的眩光； color：颜色 材质 线条基本材质 var material = new THREE.LineBasicMaterial({ vertexColors:THREE.VertexColors }); // LineBasicMaterial( parameters ) // Parameters是一个定义材质外观的对象，它包含多个属性来定义材质，这些属性是： // Color：线条的颜色，用16进制来表示，默认的颜色是白色。 // Linewidth：线条的宽度，默认时候1个单位宽度。 // Linecap：线条两端的外观，默认是圆角端点，当线条较粗的时候才看得出效果，如果线条很细，那么你几乎看不出效果了。 // Linejoin：两个线条的连接点处的外观，默认是“round”，表示圆角。 // VertexColors：定义线条材质是否使用顶点颜色，这是一个boolean值。意思是，线条各部分的颜色会根据顶点的颜色来进行插值。（将这个属性设置成THREE.VertexColors值，就可以给每个顶点指定一种颜色）。 // Fog：定义材质的颜色是否受全局雾效的影响。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>webGL</tag>
        <tag>ThreeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC下搭建react-native开发环境]]></title>
    <url>%2F2018%2F01%2F09%2FMAC%E4%B8%8B%E6%90%AD%E5%BB%BAreact-native%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[相信对于前端开发者而言react大家一点都不陌生，react-native也一定是有过一定了解的，这个技术让前端开发者可以用自己喜欢的语法和较低的学习成本，开发ios和android的原生应用，极为方便。 react-native是Facebook公司的产品，Learn Once，Write Anywhere，这也是 react-native官网 对其的概述，react-native开发基于JavaScript，这简直就是前端开发者的福音，而且Facebook还扩展出了一种可以在JaveScript代码中直接书写HTML标签的语法糖——JSX，而且论生态，react-native的社区也是非常活跃的。 废话不多说了，现在给大家简单说一下在MAC下搭建react-native开发环境的方法 开发ios环境配置首先附上官方文档 react-native搭建开发环境 安装Homebrew传送门：MAC下Homebrew的安装及简介 Node传送门：MAC下Node的安装及简介 安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用cnpm！cnpm安装的模块路径比较奇怪，packager不能正常识别！ npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global Yarn、React Native的命令行工具（react-native-cli）Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 npm install -g yarn react-native-cli 安装完yarn后同理也要设置镜像源： yarn config set registry https://registry.npm.taobao.org --global yarn config set disturl https://npm.taobao.org/dist --global 如果你看到EACCES: permission denied这样的权限报错，那么请参照上文的homebrew译注，修复/usr/local目录的所有权： sudo chown -R `whoami` /usr/local 安装完yarn之后就可以用yarn代替npm了，例如用yarn代替npm install命令，用yarn add 某第三方库名代替npm install –save 某第三方库名。 XcodeReact Native目前需要Xcode 8.0 或更高版本。 虽然一般来说命令行工具都是默认安装了，但你最好还是启动Xcode，并在Xcode | Preferences | Locations菜单中检查一下是否装有某个版本的Command Line Tools。Xcode的命令行工具中也包含一些必须的工具，比如git等。 mac下ios的环境很好配置，至此我们就完成了。 开发android环境配置首先附上官方文档 react-native搭建开发环境 安装Homebrew传送门：MAC下Homebrew的安装及简介 Node传送门：MAC下Node的安装及简介 安装完node后建议设置npm镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用cnpm！cnpm安装的模块路径比较奇怪，packager不能正常识别！ npm config set registry https://registry.npm.taobao.org --global npm config set disturl https://npm.taobao.org/dist --global Yarn、React Native的命令行工具（react-native-cli）Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。 npm install -g yarn react-native-cli 安装完yarn后同理也要设置镜像源： yarn config set registry https://registry.npm.taobao.org --global yarn config set disturl https://npm.taobao.org/dist --global 如果你看到EACCES: permission denied这样的权限报错，那么请参照上文的homebrew译注，修复/usr/local目录的所有权： sudo chown -R `whoami` /usr/local 安装完yarn之后就可以用yarn代替npm了，例如用yarn代替npm install命令，用yarn add 某第三方库名代替npm install –save 某第三方库名。 Android StudioReact Native目前需要Android Studio2.0或更高版本。Android Studio包含了运行和测试React Native应用所需的Android SDK和模拟器。 Android Studio需要Java Development Kit [JDK] 1.8（暂不支持更高版本）。你可以在命令行中输入 javac -version来查看你当前安装的JDK版本。这里提供一个1.8版本的JDK下载链接： 链接:https://pan.baidu.com/s/1cptus2 密码:l89w 如果你的电脑之前安装了高版本的JDK，需要卸载高版本的，才能安装1.8，查询JDK版本，在命令行输入： javac -version 卸载JDK，在命令行输入： sudo rm -rf /Library/Java/JavaVirtualMachines/jdk1.8.0_71.jdk（你的JDK版本） sudo rm -rf /Library/PreferencePanes/JavaControlPanel.prefPane sudo rm -rf /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin 由于担心稳定性，再提供一个Android Studio2.0版本的下载链接： 链接:https://pan.baidu.com/s/1eSxYEI2 密码:r7r2 每次进入Android Studio后都会提示更新程序，千万不要更新，不然会出现错误。想下载新版的Android Studio可以去官方下载，只是下好了就不要再更新就OK了，Android中文网。 下载好后就是安装了，除非特别注明，请不要改动安装过程中的选项。 安装过程中有一些需要改动的选项： 选择Custom选项，不要选择Standard 勾选Performance和Android Virtual Device 记住Android SDK Location，后面配置环境变量需要 安装完成后，在Android Studio的启动欢迎界面中选择Configure | SDK Manager。 在SDK Platforms窗口中，选择Show Package Details，然后在Android 6.0 (Marshmallow)中勾选Google APIs、Android SDK Platform 23、Intel x86 Atom System Image、Intel x86 Atom_64 System Image以及Google APIs Intel x86 Atom_64 System Image。 在SDK Tools窗口中，选择Show Package Details，然后在Android SDK Build Tools中勾选Android SDK Build-Tools 23.0.1（必须是这个版本）。然后还要勾选最底部的Android Support Repository. 然后点击OK，下载安装。 配置环境变量配置JAVA环境变量在命令行中输入： /usr/libexec/java_home 来定位java在mac中的安装路径，记住该路径，接着在命令行中输入： touch ~/.bash_profile （touch命令是若文件不存在，创建该文件），在命令行中输入： open ~/.bash_profile 用编辑器打开.bash_profile文件，复制以下内容到 .bash_profile文件中 export JAVA_HOME=查找到的java安装路径 export PATH=$JAVA_HOME/bin:$PATH export CLASS_PATH=$JAVA_HOME/lib:$CLASS_PATH 然后保存修改，在命令行中输入： source ~/.bash_profile 验证环境变量是否成功：在命令行输入： echo $JAVA_HOME 成功打印java的安装路径就说明配置成功了 配置Android环境变量在命令行中输入： open ~/.bash_profile 用编辑器打开.bash_profile文件，复制以下内容到 .bash_profile文件中 export ANDROID_HOME=之前安装Android Studio第三步的Android SDK路径 export PATH=${PATH}:${ANDROID_HOME}/tools export PATH=${PATH}:${ANDROID_HOME}/platform-tools 然后保存修改，在命令行中输入： source ~/.bash_profile 验证环境变量是否成功：在命令行输入： adb 验证android sdk环境变量是否设置成功 安装React Native在各种环境都安装完成后，就可以进入主题，安装react-native了，在命令行输入： npm install -g react-native-cli 安装完成后，输入： react-native -h 可以验证react-native是否安装成功，还有一些辅助软件，可以根据官方文档选择是否安装 初始化项目在命令行输入 react-native init myProject 即可初始化一个react-native项目，等待工程创建成功并安装好所有依赖以后，就可以使用一个你常用的编辑器打开myProject，来看一下react-native项目结构 运行项目ios项目在命令行输入： cd myProject react-native run-ios 即可运行ios项目 android项目首先打开Android Studio，在工具栏中找到AVD manager的图标，点击打开AVD管理器，创建一个模拟机型。 确认后可以在“Android virtual devices”中找到创建好的模拟器，启动模拟器，启动成功后，在命令行中输入 cd myProject react-native run-android 即可运行android项目 修改项目使用你喜欢的编辑器打开App.js并随便改上几行 在iOS模拟器中按下⌘+R就可以刷新APP并看到你的最新修改 在android模拟器中按下⌘+M，打开开发者菜单，然后选择 Reload JS 就可以看到你的最新修改。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>react</tag>
        <tag>react native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC下NodeJS搭建express WEB服务器]]></title>
    <url>%2F2018%2F01%2F08%2FMAC%E4%B8%8BNodeJS%E6%90%AD%E5%BB%BAexpress%20WEB%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Express 是一个简洁而灵活的 node.js Web应用框架,也是目前最火、使用率最高的框架，它提供了一系列强大特性帮助你创建各种Web应用。Express不对node.js已有的特性进行二次抽象，只是在它之上扩展了Web应用所需的功能。丰富的HTTP工具以及来自Connect框架的中间件随取随用，创建强健、友好的API变得快速又简单。 express中文官方网站，这个网站从安装到使用，再到中文API都有详细的教程，现在把简单基础的安装教程给他家展示一下。 express的安装首先你要安装node和npm，传送门：MAC搭建Node.js开发环境 假定你已经安装了 Node.js，接下来为你的应用创建一个目录myapp，然后进入此目录并将其作为当前工作目录。 cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。你可以直接按“回车”键接受默认设置即可，接下来安装 Express 并将其保存到依赖列表中： npm install express --save HelloWorld 实例接下来，我们一起创建一个基本的简单的 Express 应用。进入 myapp 目录，创建一个名为 app.js 的文件，然后将下列代码复制进去： let express = require(&apos;express&apos;); let app = express(); app.get(&apos;/&apos;, function (req, res) { res.send(&apos;Hello World!&apos;); }); let server = app.listen(3000, function () { let host = server.address().address; let port = server.address().port; console.log(&apos;Example app listening at http://%s:%s&apos;, host, port); }); 上面的代码启动一个服务并监听从 3000 端口进入的所有连接请求。他将对所有 (/) URL 或 路由 返回 “Hello World!” 字符串。对于其他所有路径全部返回 404 Not Found。 通过如下命令启动此应用： node app.js 然后在浏览器中打开 http://localhost:3000/ 并查看输出结果。 Express 应用生成器通过应用生成器工具 express 可以快速创建一个应用的骨架。 通过如下命令安装： npm install express-generator -g 在当前工作目录下创建一个命名为 myapp 的应用: express myapp 您会看到控制台输出如下信息： create : myapp create : myapp/package.json create : myapp/app.js create : myapp/public create : myapp/public/javascripts create : myapp/public/images create : myapp/routes create : myapp/routes/index.js create : myapp/routes/users.js create : myapp/public/stylesheets create : myapp/public/stylesheets/style.css create : myapp/views create : myapp/views/index.jade create : myapp/views/layout.jade create : myapp/views/error.jade create : myapp/bin create : myapp/bin/www 然后安装所有依赖包： cd myapp npm install 输入如下指令启动这个应用： npm start 然后在浏览器中打开 http://localhost:3000/ 网址就可以看到这个应用了。通过 Express 应用生成器创建的应用一般都有如下目录结构： . ├── app.js ├── bin │ └── www ├── package.json ├── public │ ├── images │ ├── javascripts │ └── stylesheets │ └── style.css ├── routes │ ├── index.js │ └── users.js └── views ├── error.jade ├── index.jade └── layout.jade 7 directories, 9 files 这样，一个基本的express框架就搭建完成了，关于路由和静态页面的相关信息，可以直接登陆中文官方网查阅。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>node.js</tag>
        <tag>express</tag>
        <tag>web服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC搭建Node.js开发环境]]></title>
    <url>%2F2018%2F01%2F05%2FMAC%E6%90%AD%E5%BB%BANode.js%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 关于NodeJS便不再赘述，也有相关的中文文档，开发十分友好， NodeJS官方网站 您可以上官网自行学习。 NodeJS的下载安装去官网下载对应的版本即可，下载好后直接安装，Node自己继承了npm，安装好以后输入如下指令，便可以查看当前安装的版本： node -v npm -v npm是nodejs的包管理器，用于node插件管理，但是其服务器在国外，所以下载的速度可能会非常缓慢，推荐修改npm包管理器的registry为淘宝镜像，淘宝npm镜像 临时修改 npm --registry https://registry.npm.taobao.org install express 永久修改 npm config set registry https://registry.npm.taobao.org 通过cnpm下载 npm install -g cnpm --registry=https://registry.npm.taobao.org 编译调试NodeJS程序选择一款你喜欢的编辑器，就可以尝试便携第一个NodeJS程序了，本文推荐 VS Code ，这是一款不错的轻量级编辑器，根据个人的需求和喜好加载插件，提高编码效率，和sublime非常相像，个人比较喜欢他的UI风格，官网即可下载，VS Code官网下载，下载安装后，可以在侧边栏扩展处选择自己喜欢的插件，我就不再详细说了，可以在网上搜索一下。本人推荐一个关于VS Code自动保存的设置，还是十分方便的，直接贴上教程的传送门：-VS Code高效开发自动保存设置的方法 接下来可以新建一个名为“helloworld.js”的js文件，在里面写入一行喜闻乐见的代码： console.log(&quot;Hello World!&quot;); 保存到一个名为HelloWorld（当然可以起任意的名字）的文件夹里，接着打开终端，进入到刚才的文件夹的位置，输入： node helloworld.js 你将会看到终端内出现了 Hello World! 的字样，这样就成功编译并运行了你的第一个NodeJS代码。 当然前面推荐VS Code也又一个原因，就是它内置了调试NodeJS的环境，您可以直接打开js文件，写完代码后直接点击调试，就会在控制台界面看到相应的输出。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC下Git的安装及配置]]></title>
    <url>%2F2018%2F01%2F05%2FMAC%E4%B8%8BGit%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone），在本地机器上拷贝一个完整的Git仓库。 Git官网 安装Git最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 方法一：可以去官网下载对应系统的版本，Git官网下载 方法二：通过homebrew指令下载，不过首先需要安装homebrew，传送门：MAC下Homebrew的安装及简介，安装完成后用下列指令安装Git： brew install git 方法三：简单许多，在MAC下只要安装了XCode，就会自动集成Git，不过没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 安装完成后，可以运行指令查看Git的版本： git --version 可以看到如下结果： git version 2.14.3 (Apple Git-98) 配置Git的用户名和邮箱当安装好Git后，我们需要一个Github的用户名和邮箱，注册的事就不再赘述了。Github官网，注册好后，记住你的用户名和邮箱，输入如下指令： git config --global user.name &quot;your_name&quot; git config --global user.email &quot;your_email&quot; 配置信息可以更改，想要更改的话就再输入上面的指令就可以了，如果想查询当前的配置信息，可以输入如下指令： git config --list Git默认是大小写不敏感的，也就是说，将一个文件名某个字母做了大小写转换的修改Git是忽略这个改动的，导致在同步代码时候会出现错误，所以建议大小把Git设置成大小写敏感。输入如下代码即可： git config core.ignorecase false 使用GitHub Desktop来将项目托管到GitHub在MAC上我们可以很方便地通过GitHub Desktop来操作github，首先登陆官网下载安装 GitHub Desktop官网，安装完成后就需要配置一下GitHub Desktop，网上的相关教程很多，我现在给大家贴一个不错的传送门 在MAC中使用Github超详细攻略，里面还有相关github的注册攻略，大家可以参照这个攻略，就可以完成在MAC下操作github来实现软件分布式版本管理了。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC下配置apache、php、mysql开发环境]]></title>
    <url>%2F2017%2F12%2F25%2FMAC%E4%B8%8B%E9%85%8D%E7%BD%AEapache%E3%80%81php%E3%80%81mysql%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;MAC系统对于开发者来说一直都是一个非常友好的环境，搭建php的环境更是方便快捷，只需很简单的配置便可以开始使用。 Apache在MAC系统中已经安装好了Apache服务，输入如下命令可以查看当前MAC的版本： apachectl -v 可以看到如下版本信息： Server version: Apache/2.4.28 (Unix) Server built: Oct 9 2017 19:54:20 启动、停止、重启apache： sudo apachectl start sudu apachectl stop sudo apachectl restart 需要输入当前MAC的密码，如果启动apache后，可以在浏览器输入如下网址： http://localhost http://127.0.0.1 如果页面显示 It works! ，祝贺你，apache已经启动成功了。apache默认安装的一个隐藏目录中，你可以在控制台输入 open /etc 找到apache的目录，也可以在Finder -&gt; 前往 -&gt; 前往文件夹中输入/etc即可，找到apache文件夹。在里面有很多的配置文件，例如 httpd.conf 等，修改这些文件，可以改变很多apache的配置，包括默认的部署路径等，但本人建议不要修改（搞了很久还是出错），如果怕每次打开默认路径麻烦，我会给你一个applescript脚本文件，直接可以打开目录。如果你还是想修改，可以借鉴一下其他人的方法，但你一定要备份原来的 httpd.conf ，不然…你懂的，我现在把一个原版2.4.28的httpd.conf下载链接给你们，以防万一啊。 链接:https://pan.baidu.com/s/1o8Jwxjc 密码:o9ti 那么刚才那个 It works! 的页面放在哪里呢，在apache的默认部署路径里： /Library/WebServer/Documents/ 你也可以通过上述两个方法进入该目录，我们以后的项目也就可以放在这个路径下了，下面我提供一个快速打开这个文件夹的脚本文件： 链接:https://pan.baidu.com/s/1geShWcz 密码:9sl6 至此，apache服务器就好了，是不是很简单啊 PHPphp也是MAC系统自带的，这给我们省去了很多麻烦，直接输入命令： php -v 可以看到当前php的版本： PHP 7.1.7 (cli) (built: Jul 15 2017 18:08:09) ( NTS ) Copyright (c) 1997-2017 The PHP Group Zend Engine v3.1.0, Copyright (c) 1998-2017 Zend Technologies 首先，找到上文提到的apache安装目录下的 httpd.conf ，找到 #LoadModule php7_module libexec/apache2/libphp7.so 将最开头的#删除，保存配置。（如果因为权限无法保存，就拖到桌面，保存完在拖回文件夹覆盖），最后我们在部署文件夹（/Library/WebServer/Documents/）内新建一个info.php的文件，输入 &lt;?php phpinfo(); ?&gt; 保存后，重启apache服务器，在浏览器里输入： http://localhost/info.php 如果能看到页面上显示的PHP信息就说明OK了！ MySqlMAC下Mysql是需要安装的，安装的方法很多，建议直接去官网 http://dev.mysql.com/downloads/mysql/ 下载，找到自己电脑相对应的版本，下载并安装。（会弹出一个对话框，上面有初始密码，请记住，方便后面更改，因为这个初始密码很难记住）输入如下命令： mysql --version 可以看到当前mysql的版本信息： mysql Ver 14.14 Distrib 5.7.20, for macos10.12 (x86_64) using EditLine wrapper 如果提示command not found,这是因为该命令默认访问/usr/local/bin/mysql路径下的mysql,所以我们可以在终端输入如下命令： sudo ln -fs /usr/local/mysql/bin/mysql /usr/local/bin/mysql 接着,使用安装MySQL时给出的用户和密码登录MySQL服务,在终端中输入如下命令，键入回车后输入mysql密码： mysql -u root -p 接着进入到了mysql的命令行，键入命令退出mysql服务。 exit 最后，在终端中更改mysql密码： /usr/local/mysql/bin/mysqladmin -u root -p password 新密码 注：root为默认用户，将新密码改成自己的密码后，键入回车输入原密码即可。回报一个warring，没关系，直接忽视。 在命令行输入如下指令,启动与停止MySQL服务： sudo /usr/local/mysql/support-files/mysql.server start sudo /usr/local/mysql/support-files/mysql.server stop 也可以在系统偏好设置中点击MySql来启动和停止mysql服务。 MySQL可视化管理mysql在MAC下有很多可视化管理软件，在这里，我推荐使用phpMyAdmin，首先去官网下载： https://www.phpmyadmin.net/downloads/ 下载后，将文件解压到apache的默认部署路径（/Library/WebServer/Documents/）下，并改名为 phpMyAdmin ，将文件夹中的 config.sample.inc.php 文件重命名为 config.inc.php，打开文件，修改代码： // 修改前: $cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;localhost&apos;; // 修改后: $cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;127.0.0.1&apos;; 最后,在浏览器中输入如下网址进行登录即可直接对MySQL进行可视化管理： http://localhost/phpmyadmin/ 注：用户为 root ，密码为修改后的密码。 至此，php的初步开发环境就搭建成功了，祝你在php的道路上越走越远！]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>apache</tag>
        <tag>php</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC下Homebrew的安装及简介]]></title>
    <url>%2F2017%2F12%2F25%2FMAC%E4%B8%8BHomebrew%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;什么是Homebrew呢？官方给出了非常清楚的解释：Homebrew是一个包管理器，用于在Mac上安装一些OS X没有的UNIX工具（比如著名的wget）。 &emsp;&emsp;Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接。 Homebrew的官方网站http://mxcl.github.com/homebrew/ Homebrew的安装Homebrew是基于Ruby的，所以安装过程也是很简单的，只要你的电脑安装了Xcode，就会自带Ruby，把下面的代码粘贴到Terminal中执行即可。 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 接着按“Enter”，输入密码，稍等片刻即将安装好Homebrew，安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序。 这时你就可以直接在命令行状态下面使用 brew 命令了。 通过 brew install就可以安装软件了,通过 brew search 就可以搜索程序，例如 brew search vim ,就可以搜索名称包括vim的程序, 通过 brew update 就可以把包信息更新到最新，不过包更新是通过Git命令，所以要先通过 brew install git 命令安装git。 brew install git Homebrew的一些命令//查看brew的帮助 brew –help //安装软件 brew install git //卸载软件 brew uninstall git //搜索软件 brew search git //显示已经安装软件列表 brew list //更新软件，把所有的Formula目录更新，并且会对本机已经安装并有更新的软件用*标明。 brew update //更新某具体软件 brew upgrade git //查看软件信息 brew [info | home] [FORMULA...] //删除程序，和upgrade一样，单个软件删除和所有程序老版删除。 brew cleanup git brew cleanup //查看那些已安装的程序需要更新 brew outdated //其它Homebrew指令: brew list //—列出已安装的软件 brew update //—更新Homebrew brew home * //—用浏览器打开 brew info * //—显示软件内容信息 brew deps * //—显示包依赖 brew server * //—启动web服务器，可以通过浏览器访问 //http://localhost:4567/ 来同网页来管理包 brew -h brew //—帮助]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>mac</tag>
        <tag>homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时光流逝，不知何时]]></title>
    <url>%2F2017%2F11%2F20%2F%E6%97%B6%E5%85%89%E6%B5%81%E9%80%9D%EF%BC%8C%E4%B8%8D%E7%9F%A5%E4%BD%95%E6%97%B6%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;人生到了这个尴尬的路口，喜闻乐见地开始了多愁善感，即入而立之年，可是状态和心态却完全没有跟上时光的荏苒…工作再一次从“实习生”起步，感觉处处相难，依旧没有多么澎湃的信心，把自己慢慢跌入中年危机的深潭。 &emsp;&emsp;恐怕心已不再年轻,让我对梦想的渴望止步于此，感觉只有生活的压力和对现状的不满催动着我为之最后一搏！ &emsp;&emsp;兜兜转转，回归如初，身边多了一个如此疼爱的人，不枉之前的蹉跎，拾之我运。亦不能负如此温情的寄托，实属我命。只有在这个充满了不解的社会里继续辗转，尽量坚持我所坚持的一切，希望我身边的人能依旧天真、幸福。]]></content>
      <categories>
        <category>随笔散文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
